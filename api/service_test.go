package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"net/url"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/felipe88alves/sortKeyHttpServer/types"
	"github.com/felipe88alves/sortKeyHttpServer/utils"
)

var serviceTestRelativePath string

func init() {
	// BasePath and RelPath must be hardcoded here for the tests to be valid.
	_, currFileLocation, _, _ := runtime.Caller(0)
	utils.BasePath = filepath.Dir(filepath.Dir(currFileLocation))

	serviceTestRelativePath = filepath.Join(
		"_test_resources",
		"service_test",
	)

	// Overwritting global params to reduce test time
	retryAttempts = 1
	backoffPeriods = []time.Duration{0}
}

func TestNewUrlStatDataService(t *testing.T) {

	testCases := []struct {
		name                string
		inputDataSourceType string
		inputDataSourcePath string
		expected            service
		expectedErr         bool
	}{
		{
			name:                "inputDataSourceType empty - inputDataSourcePath set to FILE Path - Use default HTTP value for inputDataSourceType",
			inputDataSourcePath: defaultFileDataSource,
			expected: &urlStatDataService{
				dataSourceType: urlDataSourceHttp,
				dataSourcePath: defaultFileDataSource,
			},
		},
		{
			name:                "inputDataSourceType empty - inputDataSourcePath set - Use set values",
			inputDataSourcePath: defaultHttpDataSource,
			expected: &urlStatDataService{
				dataSourceType: urlDataSourceHttp,
				dataSourcePath: defaultHttpDataSource,
			},
		},
		{
			name:                "inputDataSourceType set to HTTP - inputDataSourcePath empty - Use default values",
			inputDataSourceType: urlDataSourceHttp,
			expected: &urlStatDataService{
				dataSourceType: urlDataSourceHttp,
				dataSourcePath: defaultHttpDataSource,
			},
		},
		{
			name:                "inputDataSourceType set to File - inputDataSourcePath empty - Use default values",
			inputDataSourceType: urlDataSourceFile,
			expected: &urlStatDataService{
				dataSourceType: urlDataSourceFile,
				dataSourcePath: defaultFileDataSource,
			},
		},
		{
			name: "Empty inputs - Use default values",
			expected: &urlStatDataService{
				dataSourceType: urlDataSourceHttp,
				dataSourcePath: defaultHttpDataSource,
			},
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			result, resultErr := NewUrlStatDataService(tc.inputDataSourceType, tc.inputDataSourcePath)
			assert := reflect.DeepEqual(result, tc.expected)

			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}
			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}
		})
	}
}

func TestGetUrlStatsData_MockServer(t *testing.T) {
	const (
		usupported = "usupported"

		testFolderDataSource = "testGetUrlStatsData"
		autogeneratedUrlDir  = "autogenerated-url"
		autogeneratedUrlFile = "temp-url-autocreated"

		inputUrlPath = "/test.json"
	)

	var (
		testCtx context.Context = context.Background()

		testInputUrlStatData = &types.UrlStatData{
			Data: []*types.UrlStat{
				{
					Url:            "www.example.com/abc1",
					Views:          1000,
					RelevanceScore: 0.5,
				},
				{
					Url:            "www.example.com/abc2",
					Views:          5000,
					RelevanceScore: 0.1,
				},
				{
					Url:            "www.example.com/abc3",
					Views:          3000,
					RelevanceScore: 0.3,
				},
			},
		}
	)
	testCases := []struct {
		name                string
		inputDataSourceType string
		expectedUrlStats    *types.UrlStatData
		expectedErr         bool
	}{
		{
			name:                fmt.Sprintf("Valid Data Source Type %q", urlDataSourceFile),
			inputDataSourceType: urlDataSourceFile,
			expectedUrlStats:    testInputUrlStatData,
			expectedErr:         false,
		},
		{
			name:                fmt.Sprintf("Valid Data Source Type %q", urlDataSourceHttp),
			inputDataSourceType: urlDataSourceHttp,
			expectedUrlStats:    testInputUrlStatData,
			expectedErr:         false,
		},
		{
			name:                fmt.Sprintf("Invalid Data Source Type %q", usupported),
			inputDataSourceType: usupported,
			expectedErr:         true,
		},
	}
	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			fullPath := filepath.Join(utils.BasePath, serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir)

			if err := os.RemoveAll(fullPath); err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}
			if err := os.MkdirAll(fullPath, 0755); err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}
			defer func() {
				parentDir := fullPath[:strings.LastIndex(fullPath, "/")]
				if err := os.RemoveAll(parentDir); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
			}()

			s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				_ = json.NewEncoder(w).Encode(testInputUrlStatData)
			}))

			fullFilePath := filepath.Join(fullPath, autogeneratedUrlFile) + fileTypeBySource[tc.inputDataSourceType]
			file, err := os.Create(fullFilePath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			defer func() {
				if err := file.Close(); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
			}()
			defer func() {
				if err := os.RemoveAll(fullFilePath); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
			}()

			var fileContent string
			switch tc.inputDataSourceType {
			case urlDataSourceHttp:
				fileContent = s.URL + inputUrlPath
			case urlDataSourceFile:
				jsonInputUrlStatData, err := json.Marshal(testInputUrlStatData)
				if err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
				fileContent = string(jsonInputUrlStatData)
			}
			file.WriteString(fileContent)

			urlStatService := urlStatDataService{
				dataSourceType: tc.inputDataSourceType,
				dataSourcePath: filepath.Join(serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir),
			}

			result, resultErr := urlStatService.getUrlStatsData(testCtx)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}
		})
	}
}

func TestGetDataSourceType(t *testing.T) {
	const (
		anyValue    = "anyValue"
		unsupported = "unsupported"
	)

	testCases := []struct {
		name            string
		inputSourceType string
		expected        string
	}{
		{
			name:            fmt.Sprintf("Source Path: empty. Valid Source Type Provided: %s", urlDataSourceFile),
			inputSourceType: urlDataSourceFile,
			expected:        urlDataSourceFile,
		},
		{
			name:            fmt.Sprintf("Valid Source Type Provided: %s", urlDataSourceHttp),
			inputSourceType: urlDataSourceHttp,
			expected:        urlDataSourceHttp,
		},
		{
			name:            fmt.Sprintf("Source Path: empty. Invalid Source Type Provided: %s", unsupported),
			inputSourceType: unsupported,
			expected:        urlDataSourceHttp,
		},
		{
			name:     "empty inputs",
			expected: urlDataSourceHttp,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := getDataSourceType(tc.inputSourceType)
			if strings.Compare(result, tc.expected) != 0 {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}
		})
	}
}

func TestGetDataSource(t *testing.T) {
	const (
		anyValue    = "anyValue"
		unsupported = "unsupported"
	)

	testCases := []struct {
		name            string
		inputSourceType string
		inputSourcePath string
		expected        string
		expectedErr     bool
	}{
		{
			name:            fmt.Sprintf("Source Path: empty. Invalid Source Type Provided: %s", unsupported),
			inputSourceType: unsupported,
			expectedErr:     true,
		},
		{
			name:            fmt.Sprintf("Source Path: empty. Valid Source Type Provided: %s", urlDataSourceFile),
			inputSourceType: urlDataSourceFile,
			expected:        defaultFileDataSource,
			expectedErr:     false,
		},
		{
			name:            fmt.Sprintf("Source Path: empty. Valid Source Type Provided: %s", urlDataSourceHttp),
			inputSourceType: urlDataSourceHttp,
			expected:        defaultHttpDataSource,
			expectedErr:     false,
		},
		{
			name:            "Source Path: not empty",
			inputSourcePath: anyValue,
			expected:        anyValue,
			expectedErr:     false,
		},
		{
			name:        "empty inputs",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := getDataSource(tc.inputSourceType, tc.inputSourcePath)
			if strings.Compare(result, tc.expected) != 0 {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}
		})
	}
}

func TestGetUrlStatsDataHttpEndpointsFromFile_MockServer(t *testing.T) {
	var (
		testUrlDataSourceFile = "http"
		testFolderDataSource  = "testGetUrlStatsDataHttpEndpointsFromFile_MockServer"

		testCtx context.Context = context.Background()

		autogeneratedUrlDir  = "autogenerated-url"
		autogeneratedUrlFile = "temp-url-autocreated"
		inputUrlPath         = "/test.json"
		testInputUrlStatData = &types.UrlStatData{
			Data: []*types.UrlStat{
				{
					Url:            "www.example.com/abc1",
					Views:          1000,
					RelevanceScore: 0.5,
				},
				{
					Url:            "www.example.com/abc2",
					Views:          5000,
					RelevanceScore: 0.1,
				},
				{
					Url:            "www.example.com/abc3",
					Views:          3000,
					RelevanceScore: 0.3,
				},
			},
		}
	)
	testCases := []struct {
		name              string
		inputOverwriteUrl string
		expectedUrlStats  *types.UrlStatData
		expectedErr       bool
	}{
		{
			name:             "Valid HTTP endpoint. HTTP GET Successful",
			expectedUrlStats: testInputUrlStatData,
			expectedErr:      false,
		},
		{
			name:              "Valid HTTP endpoint. HTTP GET Failed",
			inputOverwriteUrl: "http://localhost",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
		{
			name:              "Invalid HTTP endpoint.",
			inputOverwriteUrl: "unsupported",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			fullPath := filepath.Join(utils.BasePath, serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir)

			if err := os.RemoveAll(fullPath); err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}
			if err := os.MkdirAll(fullPath, 0755); err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}
			defer func() {
				parentDir := fullPath[:strings.LastIndex(fullPath, "/")]
				if err := os.RemoveAll(parentDir); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
			}()

			s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				_ = json.NewEncoder(w).Encode(testInputUrlStatData)
			}))

			fullFilePath := filepath.Join(fullPath, autogeneratedUrlFile) + fileTypeBySource[testUrlDataSourceFile]
			file, err := os.Create(fullFilePath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			defer func() {
				if err := os.RemoveAll(fullFilePath); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
			}()
			defer func() {
				if err := file.Close(); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
			}()

			testUrl := s.URL + inputUrlPath
			if tc.inputOverwriteUrl != "" {
				testUrl = tc.inputOverwriteUrl + inputUrlPath
			}
			file.WriteString(testUrl)

			dirEntries, err := os.ReadDir(fullPath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			numberOfFilesAutoGenerated := 1
			if len(dirEntries) != numberOfFilesAutoGenerated {
				t.Fatalf("Intrnal Test Failure: %v. Expected number of loaded Files: %v Actual number of loaded Files: %v",
					tc.name, numberOfFilesAutoGenerated, len(dirEntries))
			}

			urlStatService := urlStatDataService{
				dataSourceType: testUrlDataSourceFile,
				dataSourcePath: filepath.Join(serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir),
			}

			result, resultErr := urlStatService.getUrlStatsDataHttpEndpointsFromFile(testCtx)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetUrlStatsDataHttpEndpointsFromFile_Fail(t *testing.T) {
	var (
		testUrlDataSourceFile = "http"
		testFolderDataSource  = "testGetUrlStatsDataHttpEndpointsFromFile_Fail"

		testCtx context.Context = context.Background()

		emptyDir         = "empty-dir"
		invalidUrlFormat = "invalid-url-format"
	)
	testCases := []struct {
		name               string
		inputTestDir       string
		inputTestFileCount int
		inputBasePath      string
		expectedUrlStats   *types.UrlStatData
		expectedErr        bool
	}{
		{
			name:               "Invalid Url Format",
			inputTestDir:       invalidUrlFormat,
			inputTestFileCount: 2,
			expectedErr:        true,
		},
		// {
		// 	// Can't test as is. Using test.FS could enable this test
		// 	name:                  "Non-existing file in file list",
		// 	inputTestFileLocation: filepath.Join(testFolderDataSource, "unsupported"),
		// 	expectedErr:           true,
		// },
		{
			name:         "Empty []fs.DirEntry",
			inputTestDir: emptyDir,
			expectedErr:  true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			fullPath := filepath.Join(utils.BasePath, serviceTestRelativePath, testFolderDataSource, tc.inputTestDir)
			if tc.inputTestDir == emptyDir {
				os.RemoveAll(fullPath)
				if err := os.Mkdir(fullPath, 0755); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
				defer func() {
					if err := os.RemoveAll(fullPath); err != nil {
						t.Fatalf("Internal Testing error: %v", err)
					}
				}()
			}
			dirEntries, err := os.ReadDir(fullPath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			if len(dirEntries) != tc.inputTestFileCount {
				t.Fatalf("Intrnal Test Failure: %v. Expected number of loaded Files: %v Actual number of loaded Files: %v",
					tc.name, tc.inputTestFileCount, len(dirEntries))
			}

			urlStatService := urlStatDataService{
				dataSourceType: testUrlDataSourceFile,
				dataSourcePath: filepath.Join(serviceTestRelativePath, tc.inputTestDir),
			}
			result, resultErr := urlStatService.getUrlStatsDataHttpEndpointsFromFile(testCtx)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetUrlStatsDataHttp_MockServer(t *testing.T) {
	var (
		inputUrlPath         = "/test.json"
		testInputUrlStatData = &types.UrlStatData{
			Data: []*types.UrlStat{
				{
					Url:            "www.example.com/abc1",
					Views:          1000,
					RelevanceScore: 0.5,
				},
				{
					Url:            "www.example.com/abc2",
					Views:          5000,
					RelevanceScore: 0.1,
				},
				{
					Url:            "www.example.com/abc3",
					Views:          3000,
					RelevanceScore: 0.3,
				},
			},
		}
	)
	testCases := []struct {
		name              string
		inputOverwriteUrl string
		expectedUrlStats  *types.UrlStatData
		expectedErr       bool
	}{
		{
			name:             "Valid HTTP endpoint. HTTP GET Successful",
			expectedUrlStats: testInputUrlStatData,
			expectedErr:      false,
		},
		{
			name:              "Valid HTTP endpoint. HTTP GET Failed",
			inputOverwriteUrl: "https://localhost",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
		{
			name:              "Invalid HTTP endpoint.",
			inputOverwriteUrl: "unsupported",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				_ = json.NewEncoder(w).Encode(testInputUrlStatData)
			}))

			testUrl := s.URL + inputUrlPath
			if tc.inputOverwriteUrl != "" {
				testUrl = tc.inputOverwriteUrl + inputUrlPath
			}

			result, resultErr := getUrlStatsDataHttp(testUrl)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetUrlStatsDataFromFile(t *testing.T) {
	var (
		testUrlDataSourceFile = urlDataSourceFile
		testFolderDataSource  = "testGetUrlStatsDataFromFile"

		emptyDir                  = "empty-dir"
		invalidJsonFormat         = "invalid-json-format"
		validJsonFormat           = "valid-json-format"
		validAndInvalidJsonFormat = "valid-and-invalid-json-format"

		testCtx context.Context = context.Background()
	)
	testCases := []struct {
		name               string
		inputTestDir       string
		inputTestFileCount int
		inputBasePath      string
		expectedUrlStats   *types.UrlStatData
		expectedErr        bool
	}{
		{
			name:               "Valid and Invalid Json Format",
			inputTestDir:       validAndInvalidJsonFormat,
			inputTestFileCount: 2,
			//`{"data":[{"url":"www.example.com/abc1","views":1000,"relevanceScore":0.5}]}`,
			expectedUrlStats: &types.UrlStatData{
				Data: []*types.UrlStat{
					{
						Url:            "www.example.com/abc1",
						Views:          1000,
						RelevanceScore: 0.5,
					},
				},
			},
			expectedErr: false,
		},
		{
			name:               "Valid Json Format",
			inputTestDir:       validJsonFormat,
			inputTestFileCount: 1,
			//`{"data":[{"url":"www.example.com/abc1","views":1000,"relevanceScore":0.5}]}`,
			expectedUrlStats: &types.UrlStatData{
				Data: []*types.UrlStat{
					{
						Url:            "www.example.com/abc1",
						Views:          1000,
						RelevanceScore: 0.5,
					},
				},
			},
			expectedErr: false,
		},
		{
			name:               "Invalid Json Format",
			inputTestDir:       invalidJsonFormat,
			inputTestFileCount: 1,
			expectedErr:        true,
		},
		// {
		// 	// Can't test as is. Using test.FS could enable this test
		// 	name:                  "Non-existing file in file list",
		// 	inputTestFileLocation: filepath.Join(testFolderDataSource, "unsupported"),
		// 	expectedErr:           true,
		// },
		{
			name:         "Empty []fs.DirEntry",
			inputTestDir: emptyDir,
			expectedErr:  true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			fullPath := filepath.Join(utils.BasePath, serviceTestRelativePath, testFolderDataSource, tc.inputTestDir)
			if tc.inputTestDir == emptyDir {
				os.RemoveAll(fullPath)
				if err := os.Mkdir(fullPath, 0755); err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
				defer func() {
					if err := os.RemoveAll(fullPath); err != nil {
						t.Fatalf("Internal Testing error: %v", err)
					}
				}()
			}
			dirEntries, err := os.ReadDir(fullPath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			if len(dirEntries) != tc.inputTestFileCount {
				t.Fatalf("Intrnal Test Failure: %v. Expected number of loaded Files: %v Actual number of loaded Files: %v",
					tc.name, tc.inputTestFileCount, len(dirEntries))
			}

			urlStatService := urlStatDataService{
				dataSourceType: testUrlDataSourceFile,
				dataSourcePath: filepath.Join(serviceTestRelativePath, testFolderDataSource, tc.inputTestDir),
			}
			result, resultErr := urlStatService.getUrlStatsDataFromFile(testCtx)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestValidateUrls(t *testing.T) {
	const (
		unsupported = "unsupported"
		testDomain  = "foo.bar/"
	)

	testCases := []struct {
		name        string
		inputUrls   []string
		expected    []string
		expectedErr bool
	}{
		{
			name: "mix of valid and invalid inputUrls",
			inputUrls: []string{
				validUrlPrefixProtocolHttp + testDomain + fileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + fileTypeJson,
				unsupported,
			},
			expected: []string{
				validUrlPrefixProtocolHttp + testDomain + fileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + fileTypeJson,
			},
			expectedErr: false,
		},
		{
			name: "only valid inputUrls",
			inputUrls: []string{
				validUrlPrefixProtocolHttp + testDomain + fileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + fileTypeJson,
			},
			expected: []string{
				validUrlPrefixProtocolHttp + testDomain + fileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + fileTypeJson,
			},
			expectedErr: false,
		},
		{
			name: "only invalid inputUrls",
			inputUrls: []string{
				unsupported,
			},
			expectedErr: true,
		},
		{
			name: "only invalid inputUrls: Prefix valid; Suffix invalid",
			inputUrls: []string{
				validUrlPrefixProtocolHttp + testDomain + unsupported,
				validUrlPrefixProtocolHttps + testDomain + unsupported,
			},
			expectedErr: true,
		},
		{
			name: "only invalid inputUrls: Prefix invalid; Suffix valid",
			inputUrls: []string{
				unsupported + testDomain + fileTypeJson,
			},
			expectedErr: true,
		},
		{
			name:        "empty inputUrls",
			inputUrls:   []string{},
			expectedErr: true,
		},
		{
			name:        "nil inputUrls",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := validateUrls(tc.inputUrls)
			assert := reflect.DeepEqual(result, tc.expected)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestIsValidUrlPrefixProtocol(t *testing.T) {

	const (
		unsupportedPrefixProtocol  = "unsupported://"
		testDomainFilenameFiletype = "bar.baz/qux.foo"
	)
	testCases := []struct {
		name     string
		inputUrl string
		expected bool
	}{
		{
			name:     fmt.Sprintf("inputUrl has Suffix - %s", validUrlPrefixProtocolHttp),
			inputUrl: validUrlPrefixProtocolHttp + testDomainFilenameFiletype,
			expected: true,
		},
		{
			name:     fmt.Sprintf("inputUrl has Suffix - %s", validUrlPrefixProtocolHttps),
			inputUrl: validUrlPrefixProtocolHttps + testDomainFilenameFiletype,
			expected: true,
		},
		{
			name:     "inputUrl has invalid Suffix",
			inputUrl: unsupportedPrefixProtocol + testDomainFilenameFiletype,
			expected: false,
		},
		{
			name:     "empty inputUrl",
			expected: false,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := isValidUrlPrefixProtocol(tc.inputUrl)

			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func TestIsValidUrlSuffixFileType(t *testing.T) {

	const (
		unsupportedSuffixFileType  = ".unsupported"
		testProtocolDomainFilename = "foo://bar.baz/qux"
	)
	testCases := []struct {
		name     string
		inputUrl string
		expected bool
	}{
		{
			name:     fmt.Sprintf("inputUrl has Suffix - %s", fileTypeJson),
			inputUrl: testProtocolDomainFilename + fileTypeJson,
			expected: true,
		},
		{
			name:     "inputUrl has invalid Suffix",
			inputUrl: testProtocolDomainFilename + unsupportedSuffixFileType,
			expected: false,
		},
		{
			name:     "empty inputUrl",
			expected: false,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := isValidUrlSuffixFileType(tc.inputUrl)

			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func TestMergeSort(t *testing.T) {
	urlStatA := &types.UrlStat{
		Url:            "a",
		Views:          1,
		RelevanceScore: 0.1,
	}
	urlStatB := &types.UrlStat{
		Url:            "b",
		Views:          2,
		RelevanceScore: 0.2,
	}
	urlStatC := &types.UrlStat{
		Url:            "c",
		Views:          3,
		RelevanceScore: 0.3,
	}
	urlStatD := &types.UrlStat{
		Url:            "d",
		Views:          4,
		RelevanceScore: 0.4,
	}
	urlStatE := &types.UrlStat{
		Url:            "e",
		Views:          5,
		RelevanceScore: 0.5,
	}
	const unsupportedSortOption = "unsupported"

	testCasesUrlStat := []struct {
		name                  string
		inputUrlStat          *types.UrlStatSlice
		expectedUrlStatResult *types.UrlStatSlice
		expectedErr           bool
	}{
		{
			name: "urlStat with 5 element mixed order",
			inputUrlStat: &types.UrlStatSlice{
				urlStatA,
				urlStatB,
				urlStatD,
				urlStatE,
				urlStatC,
			},
			expectedUrlStatResult: &types.UrlStatSlice{
				urlStatA,
				urlStatB,
				urlStatC,
				urlStatD,
				urlStatE,
			},
		},
		{
			name: "urlStat with 5 element all out of order",
			inputUrlStat: &types.UrlStatSlice{
				urlStatE,
				urlStatD,
				urlStatC,
				urlStatB,
				urlStatA,
			},
			expectedUrlStatResult: &types.UrlStatSlice{
				urlStatA,
				urlStatB,
				urlStatC,
				urlStatD,
				urlStatE,
			},
		},
		{
			name: "urlStat with 2 element out of order",
			inputUrlStat: &types.UrlStatSlice{
				urlStatB,
				urlStatA,
			},
			expectedUrlStatResult: &types.UrlStatSlice{
				urlStatA,
				urlStatB,
			},
		},
		{
			name: "urlStat with 2 element in order",
			inputUrlStat: &types.UrlStatSlice{
				urlStatA,
				urlStatB,
			},
			expectedUrlStatResult: &types.UrlStatSlice{
				urlStatA,
				urlStatB,
			},
		},
		{
			name: "urlStat with 1 element",
			inputUrlStat: &types.UrlStatSlice{
				urlStatE,
			},
			expectedUrlStatResult: &types.UrlStatSlice{
				urlStatE,
			},
		},
		{
			name:                  "empty urlStat",
			inputUrlStat:          &types.UrlStatSlice{},
			expectedUrlStatResult: &types.UrlStatSlice{},
		},
		{
			name:                  "nil urlStat",
			expectedUrlStatResult: nil,
			expectedErr:           true,
		},
	}

	testCasesOption := []struct {
		name        string
		inputOption string
	}{
		{
			name:        "Input Option - VIEWS",
			inputOption: relevancescoreOption,
		},
		{
			name:        "Input Option - VIEWS",
			inputOption: viewsOption,
		},
		{
			name:        "Input Option - unsupported",
			inputOption: unsupportedSortOption,
		},
	}

	for _, tcOption := range testCasesOption {
		for _, tcUrlStat := range testCasesUrlStat {
			t.Run(tcOption.name+" - "+tcUrlStat.name, func(t *testing.T) {
				t.Parallel()
				result, resultErr := mergeSort(tcUrlStat.inputUrlStat, tcOption.inputOption)

				assert := reflect.DeepEqual(result, tcUrlStat.expectedUrlStatResult)
				if !assert {
					t.Fatalf("Test Failed: %v Expected Result: %v Actual result: %v",
						tcOption.name+" - "+tcUrlStat.name, tcUrlStat.expectedUrlStatResult, result)
				}

				assertErr := resultErr != nil
				if assertErr != tcUrlStat.expectedErr {
					t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
						tcOption.name+" - "+tcUrlStat.name, tcUrlStat.expectedErr, resultErr.Error())
				}
			})

		}
	}
}

func TestIsSortedByOption(t *testing.T) {
	const (
		unsupportedTag = "unsupported"
		higherValue    = 5
		lowerValue     = 0
	)
	testCases := []struct {
		name            string
		inputSortOption string
		inputFirst      *types.UrlStat
		inputLast       *types.UrlStat
		expectedBool    bool
		expectedErr     bool
	}{
		{
			name:            "inputs: sortOption: viewsOption ; first > last",
			inputSortOption: viewsOption,
			inputFirst: &types.UrlStat{
				Views: higherValue,
			},
			inputLast: &types.UrlStat{
				Views: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:            "inputs: sortOption: viewsOption ; first < last",
			inputSortOption: viewsOption,
			inputFirst: &types.UrlStat{
				Views: lowerValue,
			},
			inputLast: &types.UrlStat{
				Views: higherValue,
			},
			expectedBool: true,
		},
		{
			name:            "inputs: sortOption: relevancescoreOption ; first > last",
			inputSortOption: relevancescoreOption,
			inputFirst: &types.UrlStat{
				RelevanceScore: higherValue,
			},
			inputLast: &types.UrlStat{
				RelevanceScore: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:            "inputs: sortOption: relevancescoreOption ; first < last",
			inputSortOption: relevancescoreOption,
			inputFirst: &types.UrlStat{
				RelevanceScore: lowerValue,
			},
			inputLast: &types.UrlStat{
				RelevanceScore: higherValue,
			},
			expectedBool: true,
		},
		{
			name:            "inputs: sortOption: unsupportedTag ; first: not nil; last: not nil",
			inputSortOption: unsupportedTag,
			inputFirst:      &types.UrlStat{},
			inputLast:       &types.UrlStat{},
			expectedErr:     true,
		},
		{
			name:        "inputs: sortOption: empty ; first: not nil; last: empty",
			inputLast:   &types.UrlStat{},
			expectedErr: true,
		},
		{
			name:        "inputs: sortOption: empty ; first: empty; last: nil",
			inputFirst:  &types.UrlStat{},
			expectedErr: true,
		},
		{
			name:            "inputs: sortOption: relevancescoreOption ; first: nil; last: nil",
			inputSortOption: relevancescoreOption,
			expectedErr:     true,
		},
		{
			name:            "inputs: sortOption: viewsOption ; first: nil; last: nil",
			inputSortOption: relevancescoreOption,
			expectedErr:     true,
		},
		{
			name:            "inputs: sortOption: unsupportedTag ; first: nil; last: nil",
			inputSortOption: unsupportedTag,
			expectedErr:     true,
		},
		{
			name:        "all inputs: nil",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := isSortedByOption(tc.inputSortOption, tc.inputFirst, tc.inputLast)
			if result != tc.expectedBool {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedBool, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestIsSortedByRelevanceScoreAscending(t *testing.T) {
	const (
		higherValue = 5
		lowerValue  = 0
	)
	testCases := []struct {
		name         string
		inputFirst   *types.UrlStat
		inputLast    *types.UrlStat
		expectedBool bool
		expectedErr  bool
	}{
		{
			name: "input: first < last",
			inputFirst: &types.UrlStat{
				RelevanceScore: lowerValue,
			},
			inputLast: &types.UrlStat{
				RelevanceScore: higherValue,
			},
			expectedBool: true,
		},
		{
			name: "input: first > last",
			inputFirst: &types.UrlStat{
				RelevanceScore: higherValue,
			},
			inputLast: &types.UrlStat{
				RelevanceScore: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:        "input first: not nil; input last: nil",
			inputLast:   &types.UrlStat{},
			expectedErr: true,
		},
		{
			name:        "input first: nil; input last: not nil",
			inputFirst:  &types.UrlStat{},
			expectedErr: true,
		},
		{
			name:        "input: nil",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := isSortedByRelevanceScoreAscending(tc.inputFirst, tc.inputLast)
			if result != tc.expectedBool {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedBool, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestIsSortedByViewsScoreAscending(t *testing.T) {
	const (
		higherValue = 5
		lowerValue  = 0
	)
	testCases := []struct {
		name         string
		inputFirst   *types.UrlStat
		inputLast    *types.UrlStat
		expectedBool bool
		expectedErr  bool
	}{
		{
			name: "input: first < last",
			inputFirst: &types.UrlStat{
				Views: lowerValue,
			},
			inputLast: &types.UrlStat{
				Views: higherValue,
			},
			expectedBool: true,
		},
		{
			name: "input: first > last",
			inputFirst: &types.UrlStat{
				Views: higherValue,
			},
			inputLast: &types.UrlStat{
				Views: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:        "input first: not nil; input last: nil",
			inputLast:   &types.UrlStat{},
			expectedErr: true,
		},
		{
			name:        "input first: nil; input last: not nil",
			inputFirst:  &types.UrlStat{},
			expectedErr: true,
		},
		{
			name:        "input: nil",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := isSortedByViewsScoreAscending(tc.inputFirst, tc.inputLast)
			if result != tc.expectedBool {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedBool, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetSortOption(t *testing.T) {
	const unsupportedTag = "unsupported"
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "valid input: viewsOption",
			input:    viewsOption,
			expected: viewsOption,
		},
		{
			name:     "valid input: relevancescoreOption",
			input:    relevancescoreOption,
			expected: relevancescoreOption,
		},
		{
			name:     "invalid input",
			input:    unsupportedTag,
			expected: relevancescoreOption,
		},
		{
			name:     "input: empty",
			expected: relevancescoreOption,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := getSortOption(tc.input)
			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func TestGetLimitValue(t *testing.T) {
	const (
		limitKey          = "limit"
		limitValueString  = "5"
		limitValueString2 = "10"

		unsupportedTag = "unsupported"
	)
	limitValueInt, err := strconv.Atoi(limitValueString)
	if err != nil {
		t.Fatalf("test Failed: %v Internal Test Failure: %v",
			"TestGetLimitValue", err.Error())
	}
	testCases := []struct {
		name     string
		input    url.Values
		expected int
	}{
		{
			name: "input: multiple keys: invalid + valid keys, valid values",
			input: map[string][]string{
				unsupportedTag: {
					limitValueString,
				},
				limitKey: {
					limitValueString,
				},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, multiple values: valid + valid values. Returns first value",
			input: map[string][]string{
				limitKey: {
					limitValueString,
					limitValueString2,
				},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, multiple values: valid + invalid values",
			input: map[string][]string{
				limitKey: {
					limitValueString,
					unsupportedTag,
				},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, valid value",
			input: map[string][]string{
				limitKey: {limitValueString},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, empty value",
			input: map[string][]string{
				limitKey: {},
			},
			expected: -1,
		},
		{
			name: "input: unsupported Key, valid value",
			input: map[string][]string{
				unsupportedTag: {limitValueString},
			},
			expected: -1,
		},
		{
			name:     "input: empty",
			input:    map[string][]string{},
			expected: -1,
		},
		{
			name:     "input: nil",
			expected: -1,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := getLimitValue(tc.input)
			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func newLimitUrlValues(d int) url.Values {
	return map[string][]string{
		limitFilterOption: {
			fmt.Sprintf("%d", d),
		},
	}
}
func TestLimitResponse(t *testing.T) {

	testCases := []struct {
		name                 string
		inputUrlStatSlice    *types.UrlStatSlice
		inputLimit           url.Values
		expectedUrlStatSlice *types.UrlStatSlice
		expectedErr          bool
	}{
		{
			name: "urlStat: not empty; 0 < Limit < len([]urlStat); filter",
			inputUrlStatSlice: &types.UrlStatSlice{
				{},
				{},
			},
			inputLimit: newLimitUrlValues(1),
			expectedUrlStatSlice: &types.UrlStatSlice{
				{},
			},
		},
		{
			name: "urlStat: not empty; Limit > len([]urlStat); no filter",
			inputUrlStatSlice: &types.UrlStatSlice{
				{},
				{},
			},
			inputLimit: newLimitUrlValues(3),
			expectedUrlStatSlice: &types.UrlStatSlice{
				{},
				{},
			},
		},
		{
			name: "urlStat: not empty; Limit < 0; no filter",
			inputUrlStatSlice: &types.UrlStatSlice{
				{},
				{},
			},
			inputLimit: newLimitUrlValues(-1),
			expectedUrlStatSlice: &types.UrlStatSlice{
				{},
				{},
			},
		},
		{
			name: "urlStat: not empty; Limit == 0; no filter",
			inputUrlStatSlice: &types.UrlStatSlice{
				{},
				{},
			},
			inputLimit: newLimitUrlValues(0),
			expectedUrlStatSlice: &types.UrlStatSlice{
				{},
				{},
			},
		},
		{
			name:                 "urlStat: empty; Limit > 0",
			inputUrlStatSlice:    &types.UrlStatSlice{},
			inputLimit:           newLimitUrlValues(1),
			expectedUrlStatSlice: &types.UrlStatSlice{},
		},
		{
			name:                 "urlStat: empty; Limit < 0",
			inputUrlStatSlice:    &types.UrlStatSlice{},
			inputLimit:           newLimitUrlValues(-1),
			expectedUrlStatSlice: &types.UrlStatSlice{},
		},
		{
			name:                 "urlStat: empty; Limit == 0",
			inputUrlStatSlice:    &types.UrlStatSlice{},
			inputLimit:           newLimitUrlValues(0),
			expectedUrlStatSlice: &types.UrlStatSlice{},
		},
		{
			name:        "urlStat: nil; Limit: > 0",
			inputLimit:  newLimitUrlValues(1),
			expectedErr: true,
		},
		{
			name:        "urlStat: nil; Limit: < 0",
			inputLimit:  newLimitUrlValues(-1),
			expectedErr: true,
		},
		{
			name:        "urlStat: nil; Limit == 0",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := limitReponse(tc.inputUrlStatSlice, tc.inputLimit)
			assert := reflect.DeepEqual(result, tc.expectedUrlStatSlice)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStatSlice, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}
