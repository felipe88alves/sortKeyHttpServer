package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"net/url"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"testing"
	"time"
)

var serviceTestBasePath, serviceTestRelativePath string

func init() {
	// Path to test files should be hardcoded here for the tests to be valid.
	_, currFileLocation, _, _ := runtime.Caller(0)
	serviceTestBasePath = filepath.Dir(currFileLocation)

	serviceTestRelativePath = filepath.Join(
		"_test_resources",
		"service_test",
	)
}

// func TestNewUrlStatDataService(t *testing.T) {

// 	testCases := []struct {
// 		name                string
// 		inputDataSourceType string
// 		inputDataSourcePath string
// 		expected            Service
// 	}{
// 		{
// 			name:                "inputDataSourceType empty - inputDataSourcePath set to FILE Path - Use default HTTP value for inputDataSourceType",
// 			inputDataSourcePath: defaultFileDataSource,
// 			expected: &urlStatDataService{
// 				dataSourceType: urlDataSourceHttp,
// 				dataSourcePath: defaultFileDataSource,
// 			},
// 		},
// 		{
// 			name:                "inputDataSourceType empty - inputDataSourcePath set - Use set values",
// 			inputDataSourcePath: defaultHttpDataSource,
// 			expected: &urlStatDataService{
// 				dataSourceType: urlDataSourceHttp,
// 				dataSourcePath: defaultHttpDataSource,
// 			},
// 		},
// 		{
// 			name:                "inputDataSourceType set to HTTP - inputDataSourcePath empty - Use default values",
// 			inputDataSourceType: urlDataSourceHttp,
// 			expected: &urlStatDataService{
// 				dataSourceType: urlDataSourceHttp,
// 				dataSourcePath: defaultHttpDataSource,
// 			},
// 		},
// 		{
// 			name:                "inputDataSourceType set to File - inputDataSourcePath empty - Use default values",
// 			inputDataSourceType: urlDataSourceFile,
// 			expected: &urlStatDataService{
// 				dataSourceType: urlDataSourceFile,
// 				dataSourcePath: defaultFileDataSource,
// 			},
// 		},
// 		{
// 			name: "Empty inputs - Use default values",
// 			expected: &urlStatDataService{
// 				dataSourceType: urlDataSourceHttp,
// 				dataSourcePath: defaultHttpDataSource,
// 			},
// 		},
// 	}

// 	for _, tc := range testCases {
// 		tc := tc
// 		t.Run(tc.name, func(t *testing.T) {
// 			result := newUrlStatDataService(tc.inputDataSourceType, tc.inputDataSourcePath)
// 			assert := reflect.DeepEqual(result, tc.expected)

// 			if !assert {
// 				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
// 					tc.name, tc.expected, result)
// 			}
// 		})
// 	}
// }

func TestGetUrlStatsData_MockServer(t *testing.T) {
	const usupported = "usupported"
	var (
		testFolderDataSource = "testGetUrlStatsData"

		testCtx context.Context = context.Background()

		autogeneratedUrlDir  = "autogenerated-url"
		gitKeepFile          = ".gitkeep"
		autogeneratedUrlFile = "temp-url-autocreated"
		inputUrlPath         = "/test.json"
		testInputUrlStatData = &urlStatData{
			Data: []*urlStat{
				{
					Url:            "www.example.com/abc1",
					Views:          1000,
					RelevanceScore: 0.5,
				},
				{
					Url:            "www.example.com/abc2",
					Views:          5000,
					RelevanceScore: 0.1,
				},
				{
					Url:            "www.example.com/abc3",
					Views:          3000,
					RelevanceScore: 0.3,
				},
			},
		}
	)
	testCases := []struct {
		name                string
		inputDataSourceType string
		inputTestFileDir    string
		expectedUrlStats    *urlStatData
		expectedErr         bool
	}{
		{
			name:                fmt.Sprintf("Valid Data Source Type %q", urlDataSourceFile),
			inputDataSourceType: urlDataSourceFile,
			inputTestFileDir:    autogeneratedUrlFile,
			expectedUrlStats:    testInputUrlStatData,
			expectedErr:         false,
		},
		{
			name:                fmt.Sprintf("Valid Data Source Type %q", urlDataSourceHttp),
			inputDataSourceType: urlDataSourceHttp,
			inputTestFileDir:    autogeneratedUrlFile,
			expectedUrlStats:    testInputUrlStatData,
			expectedErr:         false,
		},
		{
			name:                fmt.Sprintf("Invalid Data Source Type %q", usupported),
			inputDataSourceType: usupported,
			inputTestFileDir:    autogeneratedUrlFile,
			expectedErr:         true,
		},
	}
	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			fullPath := filepath.Join(serviceTestBasePath, serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir)
			// Remove .gitkeep file and create it again once the test is finished
			os.Remove(filepath.Join(fullPath, gitKeepFile))
			defer os.Create(filepath.Join(fullPath, gitKeepFile))

			s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				_ = json.NewEncoder(w).Encode(testInputUrlStatData)
			}))

			fullFilePath := filepath.Join(fullPath, autogeneratedUrlFile) + validUrlSuffixFileTypeJson
			file, err := os.Create(fullFilePath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}
			defer file.Close()
			defer os.Remove(fullFilePath)

			var fileContent string
			switch tc.inputDataSourceType {
			case urlDataSourceHttp:
				fileContent = s.URL + inputUrlPath
			case urlDataSourceFile:
				jsonInputUrlStatData, err := json.Marshal(testInputUrlStatData)
				if err != nil {
					t.Fatalf("Internal Testing error: %v", err)
				}
				fileContent = string(jsonInputUrlStatData)
			}
			file.WriteString(fileContent)

			urlStatService := urlStatDataService{
				dataSourceType: tc.inputDataSourceType,
				dataSourcePath: filepath.Join(serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir),
			}

			result, resultErr := urlStatService.getUrlStatsData(testCtx)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}
		})
	}
}

func TestGetDataSourceType(t *testing.T) {
	const (
		anyValue    = "anyValue"
		unsupported = "unsupported"
	)

	testCases := []struct {
		name            string
		inputSourceType string
		expected        string
	}{
		{
			name:            fmt.Sprintf("Source Path: empty. Valid Source Type Provided: %s", urlDataSourceFile),
			inputSourceType: urlDataSourceFile,
			expected:        urlDataSourceFile,
		},
		{
			name:            fmt.Sprintf("Valid Source Type Provided: %s", urlDataSourceHttp),
			inputSourceType: urlDataSourceHttp,
			expected:        urlDataSourceHttp,
		},
		{
			name:            fmt.Sprintf("Source Path: empty. Invalid Source Type Provided: %s", unsupported),
			inputSourceType: unsupported,
			expected:        urlDataSourceHttp,
		},
		{
			name:     "empty inputs",
			expected: urlDataSourceHttp,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := getDataSourceType(tc.inputSourceType)
			if strings.Compare(result, tc.expected) != 0 {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}
		})
	}
}

func TestGetDataSource(t *testing.T) {
	const (
		anyValue    = "anyValue"
		unsupported = "unsupported"
	)

	testCases := []struct {
		name            string
		inputSourceType string
		inputSourcePath string
		expected        string
		expectedErr     bool
	}{
		{
			name:            fmt.Sprintf("Source Path: empty. Invalid Source Type Provided: %s", unsupported),
			inputSourceType: unsupported,
			expectedErr:     true,
		},
		{
			name:            fmt.Sprintf("Source Path: empty. Valid Source Type Provided: %s", urlDataSourceFile),
			inputSourceType: urlDataSourceFile,
			expected:        defaultFileDataSource,
			expectedErr:     false,
		},
		{
			name:            fmt.Sprintf("Source Path: empty. Valid Source Type Provided: %s", urlDataSourceHttp),
			inputSourceType: urlDataSourceHttp,
			expected:        defaultHttpDataSource,
			expectedErr:     false,
		},
		{
			name:            "Source Path: not empty",
			inputSourcePath: anyValue,
			expected:        anyValue,
			expectedErr:     false,
		},
		{
			name:        "empty inputs",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := getDataSource(tc.inputSourceType, tc.inputSourcePath)
			if strings.Compare(result, tc.expected) != 0 {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}
		})
	}
}

func TestGetUrlStatsDataHttpEndpointsFromFile_MockServer(t *testing.T) {
	var (
		testUrlDataSourceFile = "http"
		testFolderDataSource  = "testGetUrlStatsDataHttpEndpointsFromFile_MockServer"

		testCtx context.Context = context.Background()

		autogeneratedUrlDir  = "autogenerated-url"
		gitKeepFile          = ".gitkeep"
		autogeneratedUrlFile = "temp-url-autocreated"
		inputUrlPath         = "/test.json"
		testInputUrlStatData = &urlStatData{
			Data: []*urlStat{
				{
					Url:            "www.example.com/abc1",
					Views:          1000,
					RelevanceScore: 0.5,
				},
				{
					Url:            "www.example.com/abc2",
					Views:          5000,
					RelevanceScore: 0.1,
				},
				{
					Url:            "www.example.com/abc3",
					Views:          3000,
					RelevanceScore: 0.3,
				},
			},
		}
	)
	testCases := []struct {
		name              string
		inputOverwriteUrl string
		expectedUrlStats  *urlStatData
		expectedErr       bool
	}{
		{
			name:             "Valid HTTP endpoint. HTTP GET Successful",
			expectedUrlStats: testInputUrlStatData,
			expectedErr:      false,
		},
		{
			name:              "Valid HTTP endpoint. HTTP GET Failed",
			inputOverwriteUrl: "http://localhost",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
		{
			name:              "Invalid HTTP endpoint.",
			inputOverwriteUrl: "unsupported",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			fullPath := filepath.Join(serviceTestBasePath, serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir)
			// Remove .gitkeep file and create it again once the test is finished
			os.Remove(filepath.Join(fullPath, gitKeepFile))
			defer os.Create(filepath.Join(fullPath, gitKeepFile))

			s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				_ = json.NewEncoder(w).Encode(testInputUrlStatData)
			}))

			fullFilePath := filepath.Join(fullPath, autogeneratedUrlFile) + validUrlSuffixFileTypeJson
			file, err := os.Create(fullFilePath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}
			defer file.Close()
			defer os.Remove(fullFilePath)

			testUrl := s.URL + inputUrlPath
			if tc.inputOverwriteUrl != "" {
				testUrl = tc.inputOverwriteUrl + inputUrlPath
			}
			file.WriteString(testUrl)

			dirEntries, err := os.ReadDir(fullPath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			numberOfFilesAutoGenerated := 1
			if len(dirEntries) != numberOfFilesAutoGenerated {
				t.Fatalf("Intrnal Test Failure: %v. Expected number of loaded Files: %v Actual number of loaded Files: %v",
					tc.name, numberOfFilesAutoGenerated, len(dirEntries))
			}

			urlStatService := urlStatDataService{
				dataSourceType: testUrlDataSourceFile,
				dataSourcePath: filepath.Join(serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir),
			}

			// Overwritting config values to reduce test time
			retryAttempts = 1
			backoffPeriods = []time.Duration{0}

			result, resultErr := urlStatService.getUrlStatsDataHttpEndpointsFromFile(testCtx, dirEntries, serviceTestBasePath)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetUrlStatsDataHttpEndpointsFromFile_Fail(t *testing.T) {
	var (
		testUrlDataSourceFile = "http"
		testFolderDataSource  = "testGetUrlStatsDataHttpEndpointsFromFile_Fail"

		testCtx context.Context = context.Background()

		emptyDir    = "empty-dir"
		gitKeepFile = ".gitkeep"
		// invalidFileExtension = "invalid-file-extension"
		invalidUrlFormat = "invalid-url-format"
	)
	testCases := []struct {
		name               string
		inputTestDir       string
		inputTestFileCount int
		inputBasePath      string
		expectedUrlStats   *urlStatData
		expectedErr        bool
	}{
		{
			name:               "Invalid Url Format",
			inputTestDir:       invalidUrlFormat,
			inputTestFileCount: 2,
			expectedErr:        true,
		},
		// {
		// 	name:               "Invalid File extension",
		// 	inputTestFileDir:   filepath.Join(testFolderDataSource, invalidFileExtension),
		// 	inputTestFileCount: 2,
		// 	expectedErr:        true,
		// },
		// {
		// 	// Can't test as is. Using test.FS could enable this test
		// 	name:                  "Non-existing file in file list",
		// 	inputTestFileLocation: filepath.Join(testFolderDataSource, "unsupported"),
		// 	expectedErr:           true,
		// },
		{
			name:         "Empty []fs.DirEntry",
			inputTestDir: emptyDir,
			expectedErr:  true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			fullPath := filepath.Join(serviceTestBasePath, serviceTestRelativePath, testFolderDataSource, tc.inputTestDir)
			if tc.inputTestDir == emptyDir {
				// Remove .gitkeep file and create it again once the test is finished
				fullFilePath := filepath.Join(fullPath, gitKeepFile)
				os.Remove(fullFilePath)
				defer os.Create(fullFilePath)
			}
			dirEntries, err := os.ReadDir(fullPath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			if len(dirEntries) != tc.inputTestFileCount {
				t.Fatalf("Intrnal Test Failure: %v. Expected number of loaded Files: %v Actual number of loaded Files: %v",
					tc.name, tc.inputTestFileCount, len(dirEntries))
			}

			urlStatService := urlStatDataService{
				dataSourceType: testUrlDataSourceFile,
				dataSourcePath: filepath.Join(serviceTestRelativePath, tc.inputTestDir),
			}
			result, resultErr := urlStatService.getUrlStatsDataHttpEndpointsFromFile(testCtx, dirEntries, serviceTestBasePath)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetUrlStatsDataHttp_MockServer(t *testing.T) {
	var (
		inputUrlPath         = "/test.json"
		testInputUrlStatData = &urlStatData{
			Data: []*urlStat{
				{
					Url:            "www.example.com/abc1",
					Views:          1000,
					RelevanceScore: 0.5,
				},
				{
					Url:            "www.example.com/abc2",
					Views:          5000,
					RelevanceScore: 0.1,
				},
				{
					Url:            "www.example.com/abc3",
					Views:          3000,
					RelevanceScore: 0.3,
				},
			},
		}
	)
	testCases := []struct {
		name              string
		inputOverwriteUrl string
		expectedUrlStats  *urlStatData
		expectedErr       bool
	}{
		{
			name:             "Valid HTTP endpoint. HTTP GET Successful",
			expectedUrlStats: testInputUrlStatData,
			expectedErr:      false,
		},
		{
			name:              "Valid HTTP endpoint. HTTP GET Failed",
			inputOverwriteUrl: "https://localhost",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
		{
			name:              "Invalid HTTP endpoint.",
			inputOverwriteUrl: "unsupported",
			expectedUrlStats:  nil,
			expectedErr:       true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			// fullPath := filepath.Join(serviceTestBasePath, serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir)
			// // Remove .gitkeep file and create it again once the test is finished
			// os.Remove(filepath.Join(fullPath, gitKeepFile))
			// defer os.Create(filepath.Join(fullPath, gitKeepFile))

			s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				_ = json.NewEncoder(w).Encode(testInputUrlStatData)
			}))

			// fullFilePath := filepath.Join(fullPath, autogeneratedUrlFile) + validUrlSuffixFileTypeJson
			// file, err := os.Create(fullFilePath)
			// if err != nil {
			// 	t.Fatalf("Internal Testing error: %v", err)
			// }
			// defer file.Close()
			// defer os.Remove(fullFilePath)

			testUrl := s.URL + inputUrlPath
			if tc.inputOverwriteUrl != "" {
				testUrl = tc.inputOverwriteUrl + inputUrlPath
			}

			// urlStatService := urlStatDataService{
			// 	dataSourceType: testUrlDataSourceFile,
			// 	dataSourcePath: filepath.Join(serviceTestRelativePath, testFolderDataSource, autogeneratedUrlDir),
			// }

			// Overwritting config values to reduce test time
			retryAttempts = 1
			backoffPeriods = []time.Duration{0}

			result, resultErr := getUrlStatsDataHttp(testUrl)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetUrlStatsDataFromFile(t *testing.T) {
	var (
		testUrlDataSourceFile = urlDataSourceFile
		testFolderDataSource  = "testGetUrlStatsDataFromFile"

		emptyDir                  = "empty-dir"
		gitKeepFile               = ".gitkeep"
		invalidJsonFormat         = "invalid-json-format"
		validJsonFormat           = "valid-json-format"
		validAndInvalidJsonFormat = "valid-and-invalid-json-format"
	)
	testCases := []struct {
		name               string
		inputTestDir       string
		inputTestFileCount int
		inputBasePath      string
		expectedUrlStats   *urlStatData
		expectedErr        bool
	}{
		{
			name:               "Valid and Invalid Json Format",
			inputTestDir:       validAndInvalidJsonFormat,
			inputTestFileCount: 2,
			//`{"data":[{"url":"www.example.com/abc1","views":1000,"relevanceScore":0.5}]}`,
			expectedUrlStats: &urlStatData{
				Data: []*urlStat{
					{
						Url:            "www.example.com/abc1",
						Views:          1000,
						RelevanceScore: 0.5,
					},
				},
			},
			expectedErr: false,
		},
		{
			name:               "Valid Json Format",
			inputTestDir:       validJsonFormat,
			inputTestFileCount: 1,
			//`{"data":[{"url":"www.example.com/abc1","views":1000,"relevanceScore":0.5}]}`,
			expectedUrlStats: &urlStatData{
				Data: []*urlStat{
					{
						Url:            "www.example.com/abc1",
						Views:          1000,
						RelevanceScore: 0.5,
					},
				},
			},
			expectedErr: false,
		},
		{
			name:               "Invalid Json Format",
			inputTestDir:       invalidJsonFormat,
			inputTestFileCount: 1,
			expectedErr:        true,
		},
		// {
		// 	// Can't test as is. Using test.FS could enable this test
		// 	name:                  "Non-existing file in file list",
		// 	inputTestFileLocation: filepath.Join(testFolderDataSource, "unsupported"),
		// 	expectedErr:           true,
		// },
		{
			name:         "Empty []fs.DirEntry",
			inputTestDir: emptyDir,
			expectedErr:  true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			fullPath := filepath.Join(serviceTestBasePath, serviceTestRelativePath, testFolderDataSource, tc.inputTestDir)
			if tc.inputTestDir == emptyDir {
				// Remove .gitkeep file and create it again once the test is finished
				fullFilePath := filepath.Join(fullPath, gitKeepFile)
				os.Remove(fullFilePath)
				defer os.Create(fullFilePath)
			}
			dirEntries, err := os.ReadDir(fullPath)
			if err != nil {
				t.Fatalf("Internal Testing error: %v", err)
			}

			if len(dirEntries) != tc.inputTestFileCount {
				t.Fatalf("Intrnal Test Failure: %v. Expected number of loaded Files: %v Actual number of loaded Files: %v",
					tc.name, tc.inputTestFileCount, len(dirEntries))
			}

			urlStatService := urlStatDataService{
				dataSourceType: testUrlDataSourceFile,
				dataSourcePath: filepath.Join(serviceTestRelativePath, testFolderDataSource, tc.inputTestDir),
			}
			result, resultErr := urlStatService.getUrlStatsDataFromFile(dirEntries, serviceTestBasePath)
			assert := reflect.DeepEqual(result, tc.expectedUrlStats)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStats, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestValidateUrls(t *testing.T) {
	const (
		unsupported = "unsupported"
		testDomain  = "foo.bar/"
	)

	testCases := []struct {
		name        string
		inputUrls   []string
		expected    []string
		expectedErr bool
	}{
		{
			name: "mix of valid and invalid inputUrls",
			inputUrls: []string{
				validUrlPrefixProtocolHttp + testDomain + validUrlSuffixFileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + validUrlSuffixFileTypeJson,
				unsupported,
			},
			expected: []string{
				validUrlPrefixProtocolHttp + testDomain + validUrlSuffixFileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + validUrlSuffixFileTypeJson,
			},
			expectedErr: false,
		},
		{
			name: "only valid inputUrls",
			inputUrls: []string{
				validUrlPrefixProtocolHttp + testDomain + validUrlSuffixFileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + validUrlSuffixFileTypeJson,
			},
			expected: []string{
				validUrlPrefixProtocolHttp + testDomain + validUrlSuffixFileTypeJson,
				validUrlPrefixProtocolHttps + testDomain + validUrlSuffixFileTypeJson,
			},
			expectedErr: false,
		},
		{
			name: "only invalid inputUrls",
			inputUrls: []string{
				unsupported,
			},
			expectedErr: true,
		},
		{
			name: "only invalid inputUrls: Prefix valid; Suffix invalid",
			inputUrls: []string{
				validUrlPrefixProtocolHttp + testDomain + unsupported,
				validUrlPrefixProtocolHttps + testDomain + unsupported,
			},
			expectedErr: true,
		},
		{
			name: "only invalid inputUrls: Prefix invalid; Suffix valid",
			inputUrls: []string{
				unsupported + testDomain + validUrlSuffixFileTypeJson,
			},
			expectedErr: true,
		},
		{
			name:        "empty inputUrls",
			inputUrls:   []string{},
			expectedErr: true,
		},
		{
			name:        "nil inputUrls",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := validateUrls(tc.inputUrls)
			assert := reflect.DeepEqual(result, tc.expected)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestIsValidUrlPrefixProtocol(t *testing.T) {

	const (
		unsupportedPrefixProtocol  = "unsupported://"
		testDomainFilenameFiletype = "bar.baz/qux.foo"
	)
	testCases := []struct {
		name     string
		inputUrl string
		expected bool
	}{
		{
			name:     fmt.Sprintf("inputUrl has Suffix - %s", validUrlPrefixProtocolHttp),
			inputUrl: validUrlPrefixProtocolHttp + testDomainFilenameFiletype,
			expected: true,
		},
		{
			name:     fmt.Sprintf("inputUrl has Suffix - %s", validUrlPrefixProtocolHttps),
			inputUrl: validUrlPrefixProtocolHttps + testDomainFilenameFiletype,
			expected: true,
		},
		{
			name:     "inputUrl has invalid Suffix",
			inputUrl: unsupportedPrefixProtocol + testDomainFilenameFiletype,
			expected: false,
		},
		{
			name:     "empty inputUrl",
			expected: false,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := isValidUrlPrefixProtocol(tc.inputUrl)

			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func TestIsValidUrlSuffixFileType(t *testing.T) {

	const (
		unsupportedSuffixFileType  = ".unsupported"
		testProtocolDomainFilename = "foo://bar.baz/qux"
	)
	testCases := []struct {
		name     string
		inputUrl string
		expected bool
	}{
		{
			name:     fmt.Sprintf("inputUrl has Suffix - %s", validUrlSuffixFileTypeJson),
			inputUrl: testProtocolDomainFilename + validUrlSuffixFileTypeJson,
			expected: true,
		},
		{
			name:     "inputUrl has invalid Suffix",
			inputUrl: testProtocolDomainFilename + unsupportedSuffixFileType,
			expected: false,
		},
		{
			name:     "empty inputUrl",
			expected: false,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := isValidUrlSuffixFileType(tc.inputUrl)

			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func TestMergeSort(t *testing.T) {
	urlStatA := &urlStat{
		Url:            "a",
		Views:          1,
		RelevanceScore: 0.1,
	}
	urlStatB := &urlStat{
		Url:            "b",
		Views:          2,
		RelevanceScore: 0.2,
	}
	urlStatC := &urlStat{
		Url:            "c",
		Views:          3,
		RelevanceScore: 0.3,
	}
	urlStatD := &urlStat{
		Url:            "d",
		Views:          4,
		RelevanceScore: 0.4,
	}
	urlStatE := &urlStat{
		Url:            "e",
		Views:          5,
		RelevanceScore: 0.5,
	}
	const unsupportedSortOption = "unsupported"

	testCasesUrlStat := []struct {
		name                  string
		inputUrlStat          *urlStatSlice
		expectedUrlStatResult *urlStatSlice
		expectedErr           bool
	}{
		{
			name: "urlStat with 5 element mixed order",
			inputUrlStat: &urlStatSlice{
				urlStatA,
				urlStatB,
				urlStatD,
				urlStatE,
				urlStatC,
			},
			expectedUrlStatResult: &urlStatSlice{
				urlStatA,
				urlStatB,
				urlStatC,
				urlStatD,
				urlStatE,
			},
		},
		{
			name: "urlStat with 5 element all out of order",
			inputUrlStat: &urlStatSlice{
				urlStatE,
				urlStatD,
				urlStatC,
				urlStatB,
				urlStatA,
			},
			expectedUrlStatResult: &urlStatSlice{
				urlStatA,
				urlStatB,
				urlStatC,
				urlStatD,
				urlStatE,
			},
		},
		{
			name: "urlStat with 2 element out of order",
			inputUrlStat: &urlStatSlice{
				urlStatB,
				urlStatA,
			},
			expectedUrlStatResult: &urlStatSlice{
				urlStatA,
				urlStatB,
			},
		},
		{
			name: "urlStat with 2 element in order",
			inputUrlStat: &urlStatSlice{
				urlStatA,
				urlStatB,
			},
			expectedUrlStatResult: &urlStatSlice{
				urlStatA,
				urlStatB,
			},
		},
		{
			name: "urlStat with 1 element",
			inputUrlStat: &urlStatSlice{
				urlStatE,
			},
			expectedUrlStatResult: &urlStatSlice{
				urlStatE,
			},
		},
		{
			name:                  "empty urlStat",
			inputUrlStat:          &urlStatSlice{},
			expectedUrlStatResult: &urlStatSlice{},
		},
		{
			name:                  "nil urlStat",
			expectedUrlStatResult: nil,
			expectedErr:           true,
		},
	}

	testCasesOption := []struct {
		name        string
		inputOption string
	}{
		{
			name:        "Input Option - VIEWS",
			inputOption: relevancescoreOption,
		},
		{
			name:        "Input Option - VIEWS",
			inputOption: viewsOption,
		},
		{
			name:        "Input Option - unsupported",
			inputOption: unsupportedSortOption,
		},
	}

	for _, tcOption := range testCasesOption {
		for _, tcUrlStat := range testCasesUrlStat {
			t.Run(tcOption.name+" - "+tcUrlStat.name, func(t *testing.T) {
				t.Parallel()
				result, resultErr := mergeSort(tcUrlStat.inputUrlStat, tcOption.inputOption)

				assert := reflect.DeepEqual(result, tcUrlStat.expectedUrlStatResult)
				if !assert {
					t.Fatalf("Test Failed: %v Expected Result: %v Actual result: %v",
						tcOption.name+" - "+tcUrlStat.name, tcUrlStat.expectedUrlStatResult, result)
				}

				assertErr := resultErr != nil
				if assertErr != tcUrlStat.expectedErr {
					t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
						tcOption.name+" - "+tcUrlStat.name, tcUrlStat.expectedErr, resultErr.Error())
				}
			})

		}
	}
}

func TestIsSortedByOption(t *testing.T) {
	const (
		unsupportedTag = "unsupported"
		higherValue    = 5
		lowerValue     = 0
	)
	testCases := []struct {
		name            string
		inputSortOption string
		inputFirst      *urlStat
		inputLast       *urlStat
		expectedBool    bool
		expectedErr     bool
	}{
		{
			name:            "inputs: sortOption: viewsOption ; first > last",
			inputSortOption: viewsOption,
			inputFirst: &urlStat{
				Views: higherValue,
			},
			inputLast: &urlStat{
				Views: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:            "inputs: sortOption: viewsOption ; first < last",
			inputSortOption: viewsOption,
			inputFirst: &urlStat{
				Views: lowerValue,
			},
			inputLast: &urlStat{
				Views: higherValue,
			},
			expectedBool: true,
		},
		{
			name:            "inputs: sortOption: relevancescoreOption ; first > last",
			inputSortOption: relevancescoreOption,
			inputFirst: &urlStat{
				RelevanceScore: higherValue,
			},
			inputLast: &urlStat{
				RelevanceScore: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:            "inputs: sortOption: relevancescoreOption ; first < last",
			inputSortOption: relevancescoreOption,
			inputFirst: &urlStat{
				RelevanceScore: lowerValue,
			},
			inputLast: &urlStat{
				RelevanceScore: higherValue,
			},
			expectedBool: true,
		},
		{
			name:            "inputs: sortOption: unsupportedTag ; first: not nil; last: not nil",
			inputSortOption: unsupportedTag,
			inputFirst:      &urlStat{},
			inputLast:       &urlStat{},
			expectedErr:     true,
		},
		{
			name:        "inputs: sortOption: nil ; first: nil; last: not nil",
			inputLast:   &urlStat{},
			expectedErr: true,
		},
		{
			name:        "inputs: sortOption: nil ; first: nil; last: not nil",
			inputLast:   &urlStat{},
			expectedErr: true,
		},
		{
			name:        "inputs: sortOption: nil ; first: nil; last: not nil",
			inputLast:   &urlStat{},
			expectedErr: true,
		},
		{
			name:        "inputs: sortOption: nil ; first: not nil; last: nil",
			inputFirst:  &urlStat{},
			expectedErr: true,
		},
		{
			name:        "inputs: sortOption: nil ; first: not nil; last: nil",
			inputFirst:  &urlStat{},
			expectedErr: true,
		},
		{
			name:        "inputs: sortOption: nil ; first: not nil; last: nil",
			inputFirst:  &urlStat{},
			expectedErr: true,
		},
		{
			name:            "inputs: sortOption: relevancescoreOption ; first: nil; last: nil",
			inputSortOption: relevancescoreOption,
			expectedErr:     true,
		},
		{
			name:            "inputs: sortOption: viewsOption ; first: nil; last: nil",
			inputSortOption: relevancescoreOption,
			expectedErr:     true,
		},
		{
			name:            "inputs: sortOption: unsupportedTag ; first: nil; last: nil",
			inputSortOption: unsupportedTag,
			expectedErr:     true,
		},
		{
			name:        "all inputs: nil",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := isSortedByOption(tc.inputSortOption, tc.inputFirst, tc.inputLast)
			if result != tc.expectedBool {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedBool, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestIsSortedByRelevanceScoreAscending(t *testing.T) {
	const (
		higherValue = 5
		lowerValue  = 0
	)
	testCases := []struct {
		name         string
		inputFirst   *urlStat
		inputLast    *urlStat
		expectedBool bool
		expectedErr  bool
	}{
		{
			name: "input: first < last",
			inputFirst: &urlStat{
				RelevanceScore: lowerValue,
			},
			inputLast: &urlStat{
				RelevanceScore: higherValue,
			},
			expectedBool: true,
		},
		{
			name: "input: first > last",
			inputFirst: &urlStat{
				RelevanceScore: higherValue,
			},
			inputLast: &urlStat{
				RelevanceScore: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:        "input first: not nil; input last: nil",
			inputLast:   &urlStat{},
			expectedErr: true,
		},
		{
			name:        "input first: nil; input last: not nil",
			inputFirst:  &urlStat{},
			expectedErr: true,
		},
		{
			name:        "input: nil",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := isSortedByRelevanceScoreAscending(tc.inputFirst, tc.inputLast)
			if result != tc.expectedBool {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedBool, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestIsSortedByViewsScoreAscending(t *testing.T) {
	const (
		higherValue = 5
		lowerValue  = 0
	)
	testCases := []struct {
		name         string
		inputFirst   *urlStat
		inputLast    *urlStat
		expectedBool bool
		expectedErr  bool
	}{
		{
			name: "input: first < last",
			inputFirst: &urlStat{
				Views: lowerValue,
			},
			inputLast: &urlStat{
				Views: higherValue,
			},
			expectedBool: true,
		},
		{
			name: "input: first > last",
			inputFirst: &urlStat{
				Views: higherValue,
			},
			inputLast: &urlStat{
				Views: lowerValue,
			},
			expectedBool: false,
		},
		{
			name:        "input first: not nil; input last: nil",
			inputLast:   &urlStat{},
			expectedErr: true,
		},
		{
			name:        "input first: nil; input last: not nil",
			inputFirst:  &urlStat{},
			expectedErr: true,
		},
		{
			name:        "input: nil",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := isSortedByViewsScoreAscending(tc.inputFirst, tc.inputLast)
			if result != tc.expectedBool {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedBool, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}

func TestGetSortOption(t *testing.T) {
	const unsupportedTag = "unsupported"
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "valid input: viewsOption",
			input:    viewsOption,
			expected: viewsOption,
		},
		{
			name:     "valid input: relevancescoreOption",
			input:    relevancescoreOption,
			expected: relevancescoreOption,
		},
		{
			name:     "invalid input",
			input:    unsupportedTag,
			expected: relevancescoreOption,
		},
		{
			name:     "input: empty",
			expected: relevancescoreOption,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := getSortOption(tc.input)
			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func TestGetLimitValue(t *testing.T) {
	const (
		limitKey          = "limit"
		limitValueString  = "5"
		limitValueString2 = "10"

		unsupportedTag = "unsupported"
	)
	limitValueInt, err := strconv.Atoi(limitValueString)
	if err != nil {
		t.Fatalf("test Failed: %v Internal Test Failure: %v",
			"TestGetLimitValue", err.Error())
	}
	testCases := []struct {
		name     string
		input    url.Values
		expected int
	}{
		{
			name: "input: multiple keys: invalid + valid keys, valid values",
			input: map[string][]string{
				unsupportedTag: {
					limitValueString,
				},
				limitKey: {
					limitValueString,
				},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, multiple values: valid + valid values. Returns first value",
			input: map[string][]string{
				limitKey: {
					limitValueString,
					limitValueString2,
				},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, multiple values: valid + invalid values",
			input: map[string][]string{
				limitKey: {
					limitValueString,
					unsupportedTag,
				},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, valid value",
			input: map[string][]string{
				limitKey: {limitValueString},
			},
			expected: limitValueInt,
		},
		{
			name: "input: valid key, empty value",
			input: map[string][]string{
				limitKey: {},
			},
			expected: -1,
		},
		{
			name: "input: unsupported Key, valid value",
			input: map[string][]string{
				unsupportedTag: {limitValueString},
			},
			expected: -1,
		},
		{
			name:     "input: empty",
			input:    map[string][]string{},
			expected: -1,
		},
		{
			name:     "input: nil",
			expected: -1,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result := getLimitValue(tc.input)
			if result != tc.expected {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expected, result)
			}

		})
	}
}

func TestLimitResponse(t *testing.T) {

	testCases := []struct {
		name                 string
		inputUrlStatSlice    *urlStatSlice
		inputLimit           int
		expectedUrlStatSlice *urlStatSlice
		expectedErr          bool
	}{
		{
			name: "urlStat: not empty; 0 < Limit < len([]urlStat); filter",
			inputUrlStatSlice: &urlStatSlice{
				{},
				{},
			},
			inputLimit: 1,
			expectedUrlStatSlice: &urlStatSlice{
				{},
			},
		},
		{
			name: "urlStat: not empty; Limit > len([]urlStat); no filter",
			inputUrlStatSlice: &urlStatSlice{
				{},
				{},
			},
			inputLimit: 3,
			expectedUrlStatSlice: &urlStatSlice{
				{},
				{},
			},
		},
		{
			name: "urlStat: not empty; Limit < 0; no filter",
			inputUrlStatSlice: &urlStatSlice{
				{},
				{},
			},
			inputLimit: -1,
			expectedUrlStatSlice: &urlStatSlice{
				{},
				{},
			},
		},
		{
			name: "urlStat: not empty; Limit == 0; no filter",
			inputUrlStatSlice: &urlStatSlice{
				{},
				{},
			},
			inputLimit: 0,
			expectedUrlStatSlice: &urlStatSlice{
				{},
				{},
			},
		},
		{
			name:                 "urlStat: empty; Limit > 0",
			inputUrlStatSlice:    &urlStatSlice{},
			inputLimit:           1,
			expectedUrlStatSlice: &urlStatSlice{},
		},
		{
			name:                 "urlStat: empty; Limit < 0",
			inputUrlStatSlice:    &urlStatSlice{},
			inputLimit:           -1,
			expectedUrlStatSlice: &urlStatSlice{},
		},
		{
			name:                 "urlStat: empty; Limit == 0",
			inputUrlStatSlice:    &urlStatSlice{},
			inputLimit:           0,
			expectedUrlStatSlice: &urlStatSlice{},
		},
		{
			name:        "urlStat: nil; Limit: > 0",
			inputLimit:  1,
			expectedErr: true,
		},
		{
			name:        "urlStat: nil; Limit: < 0",
			inputLimit:  -1,
			expectedErr: true,
		},
		{
			name:        "urlStat: nil; Limit == 0",
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			result, resultErr := limitReponse(tc.inputUrlStatSlice, tc.inputLimit)
			assert := reflect.DeepEqual(result, tc.expectedUrlStatSlice)
			if !assert {
				t.Fatalf("Test Failed: %v. Expected Result: %v Actual Result: %v",
					tc.name, tc.expectedUrlStatSlice, result)
			}

			assertErr := resultErr != nil
			if assertErr != tc.expectedErr {
				t.Fatalf("Test Failed: %v. Expected Error to occur: %v. Returned Error: %v",
					tc.name, tc.expectedErr, resultErr.Error())
			}

		})
	}
}
